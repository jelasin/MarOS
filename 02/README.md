# 项目02 - 引导扇区汇编程序教程(二)

## 项目概述

这是一个进阶的16位x86汇编语言引导扇区程序，展示了数学运算、字符串操作、堆栈管理和数字显示等高级功能。程序计算1到100的累加和并在屏幕上显示结果。

## 文件结构

- `boot.S` - 主要的汇编源代码文件
- `Makefile` - 构建脚本（如果存在）

## 代码功能

1. **字符串显示**：在屏幕上显示提示文本 "1+2+3+...+100="
2. **数学运算**：计算1到100的累加和（结果为5050）
3. **堆栈操作**：使用堆栈进行数字位数的临时存储
4. **数字显示**：将计算结果转换为十进制并显示在屏幕上

## 核心知识点详解

### 1. 程序结构设计

#### 数据与代码的分离

```assembly
jmp near start                    ; 跳转到程序开始执行点
message db '1+2+3+...+100='       ; 数据定义区
start:                            ; 程序开始
```

这种设计将数据定义和代码执行分离，是汇编程序的经典结构。跳转指令确保程序不会执行数据区域的内容。

#### 内存布局分析

| 地址范围 | 内容 | 说明 |
|----------|------|------|
| 0x7C00 | JMP指令 | 3字节跳转指令 |
| 0x7C03 | message字符串 | 提示文本数据 |
| 0x7C00+offset | start标号 | 程序主体开始 |

### 2. 字符串显示技术

#### 手工循环实现

```assembly
mov si,message                ; SI指向message字符串
mov di,0                      ; DI指向显存起始位置
mov cx,(start-message)        ; CX = 字符串长度
@g:
    mov al,[si]                   ; 读取字符
    mov [es:di],al                ; 写入显存
    inc di                        ; 移动到下一个显存位置
    mov byte [es:di],0x07         ; 设置字符属性
    inc di                        ; 移动到下一个字符位置
    inc si                        ; 指向下一个源字符
    loop @g                       ; 循环显示
```

与项目01不同，这里使用了手工循环而非`REP MOVSB`，提供了更精确的控制。

#### 长度计算技巧

`(start-message)` 在编译时计算字符串长度，这是汇编语言中常用的技巧。

### 3. 数学运算算法

#### 累加和计算

```assembly
xor ax,ax                     ; 清零AX寄存器，用作累加器
mov cx,1                      ; CX作为循环计数器，从1开始
@f:
    add ax,cx                     ; AX += CX（累加当前数值）
    inc cx                        ; CX++（下一个数）
    cmp cx,100                    ; 比较CX是否超过100
    jle @f                        ; 如果CX <= 100则继续循环
```

**算法分析**：

- 使用AX作为累加器
- 使用CX作为循环变量
- 循环从1到100，每次将当前数值加入累加器
- 最终结果：1+2+3+...+100 = 5050

#### 数学公式验证

累加和公式：$\sum_{i=1}^{n} i = \frac{n(n+1)}{2}$

当n=100时：$\frac{100 \times 101}{2} = 5050$

### 4. 堆栈管理

#### 堆栈段设置

```assembly
xor cx,cx                     ; 清零CX寄存器
mov ss,cx                     ; 设置堆栈段基地址为0
mov sp,cx                     ; 设置栈指针为0
```

**堆栈操作详解**：

| 寄存器 | 作用 | 设置值 |
|--------|------|--------|
| SS | 堆栈段寄存器 | 0x0000 |
| SP | 堆栈指针 | 0x0000 |
| 物理地址 | SS:SP | 0x0000:0x0000 |

#### 堆栈的作用

堆栈用于临时存储数字的各个位数，实现"后进先出"的数据结构，确保数字位数的正确显示顺序。

### 5. 数字转换与显示

#### 十进制分解算法

```assembly
mov bx,10                     ; BX = 10，用作除数
xor cx,cx                     ; 清零CX，用作数位计数器
@d:
    inc cx                        ; 数位计数器加1
    xor dx,dx                     ; 清零DX寄存器
    div bx                        ; AX除以10，商在AX，余数在DX
    or dl,0x30                    ; 将余数转换为ASCII字符
    push dx                       ; 将数位字符压入栈中
    cmp ax,0                      ; 检查商是否为0
    jne @d                        ; 如果商不为0，继续提取下一位
```

**算法流程**（以5050为例）：

| 步骤 | 被除数 | 除数 | 商 | 余数 | ASCII | 入栈 |
|------|--------|------|----|----|-------|------|
| 1 | 5050 | 10 | 505 | 0 | '0' | '0' |
| 2 | 505 | 10 | 50 | 5 | '5' | '5' |
| 3 | 50 | 10 | 5 | 0 | '0' | '0' |
| 4 | 5 | 10 | 0 | 5 | '5' | '5' |

#### 数字显示

```assembly
@a:
    pop dx                        ; 从栈中弹出一个数位字符
    mov [es:di],dl                ; 将数位字符写入显存
    inc di                        ; 移动到下一个显存位置
    mov byte [es:di],0x07         ; 设置字符属性
    inc di                        ; 移动到下一个字符位置
    loop @a                       ; 循环直到所有数位显示完毕
```

**出栈顺序**：'5' → '0' → '5' → '0'，正确显示为"5050"

### 6. 局部标号的使用

#### 标号命名规则

程序使用了局部标号（@符号开头）：

| 标号 | 功能 | 说明 |
|------|------|------|
| @g | 字符串显示循环 | 逐字符显示提示文本 |
| @f | 数学运算循环 | 计算累加和 |
| @d | 数位分解循环 | 将数字分解为各个位数 |
| @a | 数字显示循环 | 从栈中取出位数显示 |

局部标号的优点是避免全局命名冲突，使代码更加清晰。

## 扩展知识

### 1. 汇编程序设计模式

#### 循环结构设计

```assembly
; 初始化
mov cx, count
label:
    ; 循环体
    loop label
```

#### 条件跳转模式

```assembly
compare:
    cmp reg1, reg2
    jle continue      ; 小于等于则继续
    jmp exit          ; 否则退出
continue:
    ; 继续执行
    jmp compare
exit:
```

### 2. 数据类型和操作

#### 16位运算限制

- AX寄存器最大值：65535
- 1到100的累加和（5050）在16位范围内
- 超出范围需要使用32位运算

#### ASCII转换技巧

| 操作 | 指令 | 说明 |
|------|------|------|
| 数字→ASCII | `or dl,0x30` | 加上0x30 |
| ASCII→数字 | `and dl,0x0F` | 去掉高4位 |

### 3. 内存和堆栈管理

#### 段寄存器配置

```assembly
mov ax,0x7c0      ; 数据段
mov ds,ax
mov ax,0xb800     ; 显存段
mov es,ax
mov ss,0          ; 堆栈段
mov sp,0          ; 堆栈指针
```

#### 堆栈操作安全

- 确保堆栈段正确设置
- 避免堆栈溢出
- 保持压栈和出栈的平衡

### 4. 性能优化技巧

#### 寄存器使用优化

- 使用XOR清零比MOV 0更快
- 合理分配寄存器用途
- 避免不必要的内存访问

#### 循环优化

- 使用LOOP指令简化循环控制
- 减少循环内的指令数量
- 合理安排循环变量

## 编译和运行

### 编译命令

```bash
nasm -f bin boot.S -o boot.bin
```

### 运行测试

```bash
qemu-system-i386 -fda boot.bin
```

### 预期输出

屏幕显示：`1+2+3+...+100=5050`

## 调试技巧

### 1. 关键点调试

```assembly
; 在关键位置添加调试代码
mov ax,0x0E42     ; 显示字符'B'用于标记
int 0x10          ; BIOS视频中断
```

### 2. 数值检查

```assembly
; 检查寄存器值
mov dx,ax         ; 将AX值复制到DX
; 然后使用数字转换算法显示DX的值
```

### 3. 内存检查

使用调试器检查关键内存位置：

- 0x7C00：程序加载地址
- 0xB8000：显存起始地址
- 堆栈区域：检查压栈和出栈操作

## 常见问题

### 1. 堆栈溢出

**问题**：堆栈指针设置不当导致程序崩溃

**解决**：确保SS和SP正确设置，避免与其他内存区域冲突

### 2. 数字显示错误

**问题**：数字位数显示不正确

**解决**：检查压栈和出栈的平衡，确保CX计数器正确

### 3. 循环无限执行

**问题**：循环条件设置错误

**解决**：仔细检查循环条件和跳转指令

## 学习价值

通过这个项目，学习者可以掌握：

1. **程序结构设计**：数据与代码分离的重要性
2. **数学运算实现**：在汇编层面实现复杂计算
3. **堆栈管理**：理解堆栈的工作原理和应用
4. **字符串处理**：手工循环与自动循环的区别
5. **数字转换**：十进制数字的分解与显示技术

## 进阶挑战

1. **扩展计算范围**：支持更大数值的累加运算
2. **添加用户输入**：让用户指定累加的范围
3. **优化算法**：使用数学公式直接计算而非循环
4. **美化显示**：添加更多的提示信息和格式化

## 参考资料

1. **8086汇编语言程序设计** - 王爽
2. **IBM PC汇编语言程序设计** - Peter Abel
3. **Intel 8086 Programmer's Reference Manual**
4. **汇编语言：基于x86处理器** - Kip R. Irvine

---

*本教程详细分析了项目02的汇编代码，适合已有基础汇编知识的学习者进一步提高编程技能。*
